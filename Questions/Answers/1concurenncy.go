package main

//func main() {
//	ch := make(chan bool, 2)
//	ch <- true
//	ch <- true
//	close(ch)
//
//	for i := 0; i < cap(ch)+1; i++ {
//		v, ok := <-ch
//		fmt.Println(v, ok)
//	}
//}

// В этом примере мы создаем канал с буфером из двух элементов, заполняем буфер, а затем закрываем его.
// true true
// true true
// false false
// Запуск программы показывает, что мы получаем первые два значения, отправленные в канал, а с третьей попытки канал выдаёт нам значения false и false.
// Первое значение false - это нулевое значение для типа канала, то есть false, так как канал имеет тип chan bool.
// Второе значение указывает на открытое состояние канала, которое теперь равно false, что означает, что канал закрыт.
// Канал будет продолжать сообщать эти значения бесконечно. В качестве эксперимента изменим этот пример так, чтобы прочитать из канала 100 раз.

// Способность определять, закрыт ли канал, является полезным свойством, оно используется в идиоме "range over channel" для выхода из цикла после того, как канал был исчерпан.
//
//	func main() {
//		ch := make(chan bool, 2)
//		ch <- true
//		ch <- true
//		close(ch)
//
//		for v := range ch {
//			fmt.Println(v)
//		}
//	}
//
// Но по-настоящему проявляет себя в сочетании с select. Начнём с такого примера:
//func main() {
//	finish := make(chan bool)
//	var done sync.WaitGroup
//	done.Add(1)
//	go func() {
//		select {
//		case <-time.After(1 * time.Hour):
//		case <-finish:
//		}
//		done.Done()
//	}()
//	t0 := time.Now()
//	finish <- true
//	done.Wait()
//	fmt.Printf("Waited %v for goroutine to stop\n", time.Since(t0))
//}

// Однако в этой программе есть несколько проблем. Первая - канал finish не буферизован, поэтому посылка в finish может заблокироваться, если получатель забудет добавить finish в оператор select.
// Эту проблему можно решить, обернув посылку в блок select, чтобы сделать её неблокируемой, или сделав канал finish буферизованным. Однако если в канале finish будет прослушиваться множество горутин,
// то необходимо будет отслеживать это и не забывать отправлять нужное количество раз в канал finish. Это может оказаться сложной задачей, если вы не контролируете создание этих горутин;
// они могут создаваться в другой части вашей программы, возможно, в ответ на входящие запросы по сети.
// Хорошим решением этой проблемы является использование свойства, согласно которому закрытый канал всегда готов к приёму.
// Используя это свойство, мы можем переписать программу, включающую теперь 100 горутин, без необходимости отслеживать количество порождённых горутин или правильно определять размер канала finish:

//func main() {
//	const n = 100
//	finish := make(chan bool)
//	var done sync.WaitGroup
//	for i := 0; i < n; i++ {
//		done.Add(1)
//		go func() {
//			select {
//			case <-time.After(1 * time.Hour):
//			case <-finish:
//			}
//			done.Done()
//		}()
//	}
//	t0 := time.Now()
//	close(finish) // closing finish makes it ready to receive
//	done.Wait()   // wait for all goroutines to stop
//	fmt.Printf("Waited %v for %d goroutines to stop\n", time.Since(t0), n)
//}
//Что же здесь происходит? Как только канал finish закрывается, он становится готовым к приёму.
//Поскольку все горутины ожидают приёма либо по своему каналу time.After, либо по каналу finish, то оператор select завершается, и горутины выходят из системы после вызова done.Done(), чтобы деинкрементировать счетчик WaitGroup.
//Эта мощная идиома позволяет использовать канал для посылки сигнала неизвестному числу горутин, не зная о них ничего и не опасаясь возникновения блокировки (deadlock).

// Канал с нулевым значением всегда блокируется
// Нулевой канал; значение канала, которое не было инициализировано или было установлено в nil, всегда будет блокироваться. Например:
//package main
//
//func main() {
//	var ch chan bool
//	ch <- true // blocks forever
//}
//блокируется, так как ch - это nil и он никогда не будет готов к отправке. То же самое справедливо и для приёма:
//package main
//
//func main() {
//	var ch chan bool
//	<-ch // blocks forever
//}
