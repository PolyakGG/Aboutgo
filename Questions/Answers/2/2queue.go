// В Go (Golang) очереди играют важную роль в управлении горутинами и балансировке нагрузки.
// В языке Go используется модель планировщика, которая включает в себя локальные и глобальные очереди для эффективного управления горутинами.
//
// Локальная очередь
// Локальная очередь (local run queue) привязана к конкретному процессору (P, Processor). В Go каждый процессор (P) имеет свою локальную очередь, в которой хранятся горутины, готовые к выполнению.
// Когда горутина создается, она добавляется в локальную очередь того процессора, на котором она была создана. Процессор (P) будет выполнять горутины из своей локальной очереди до тех пор, пока они не закончатся.
//
// Глобальная очередь
// Глобальная очередь (global run queue) используется для балансировки нагрузки между процессорами.
// Когда локальная очередь процессора становится пустой, процессор может взять горутину из глобальной очереди. Глобальная очередь также используется для хранения новых горутин, если локальная очередь переполнена.
//
// Пример кода
// Вот пример кода, который демонстрирует создание и выполнение горутин в Go:
package main

import (
	"fmt"
	"runtime"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	numGoroutines := 10

	// Устанавливаем количество процессоров
	runtime.GOMAXPROCS(2)

	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			fmt.Printf("Goroutine %d is running\n", i)
		}(i)
	}

	wg.Wait()
	fmt.Println("All goroutines have finished")
}
