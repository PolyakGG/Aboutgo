// Green threads, также известные как виртуальные потоки, управляемые на уровне приложения, а не операционной системы, являются важной концепцией в Go (Golang).
// В Go они реализованы через горутины (goroutines). Вот основные моменты, которые стоит знать о green threads в контексте Go:
//
// Горутины (Goroutines)
// Легковесные нити исполнения: Горутины являются легковесными потоками, которые управляются планировщиком Go, а не операционной системой.
// Это позволяет создавать тысячи или даже миллионы горутин без значительного потребления ресурсов.
// Минимальный контекст исполнения: Горутины имеют минимальный контекст исполнения, включающий стек, указатели и локальные переменные.
// Это делает их создание и переключение между ними очень быстрыми и эффективными.
// Преимущества горутин
// Меньшее потребление ресурсов: Горутины потребляют значительно меньше ресурсов по сравнению с потоками ОС.
// Это связано с тем, что они имеют меньший стек и управляются на уровне приложения.
// Простота создания и масштабирования: Создание горутины в Go очень просто и не требует значительных затрат.
// Это позволяет легко масштабировать приложения, используя большое количество горутин.
// Контекст свитчинг
// Эффективное переключение: Переключение между горутинами требует меньше ресурсов и времени, чем переключение потоков ОС.
// Это связано с тем, что планировщик Go оптимизирован для работы с горутинами.
// Планировщик Go
// GMP модель: Планировщик Go использует модель GMP (Goroutine, Machine, Processor):
// G (Goroutine): Горутины.
// M (Machine): Потоки ОС, которые исполняют горутины.
// P (Processor): Абстракция, контролирующая выполнение горутин.
// Вытесняющая многозадачность: Планировщик Go использует вытесняющую многозадачность, что означает, что он сам решает, когда прервать горутину для переключения.
// Примитивы синхронизации
// Mutex: Примитив для обеспечения взаимного исключения при доступе к разделяемым ресурсам.
// RWMutex: Разделяемый мьютекс для чтения и записи.
// WaitGroup: Ожидание завершения группы горутин.
// Cond: Условная переменная для оповещения горутин о состоянии.
// Проблемы concurrency программирования
// Дедлоки (Deadlocks): Ситуации, когда две или более горутины ждут освобождения ресурса, удерживаемого другой.
// Лайфлоки (Livelocks): Ситуации, когда горутины постоянно изменяют свое состояние, не достигая прогресса.
// Рейс-кондишен (Race Condition): Проблема, возникающая при неконтролируемом доступе к разделяемым данным из нескольких горутин.
// Data Races: Конфликт доступа к памяти между горутинами.
// Пример использования горутин
package main

import (
	"fmt"
	"sync"
)

func printNumbers(wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 1; i <= 5; i++ {
		fmt.Println(i)
	}
}

func main() {
	var wg sync.WaitGroup
	wg.Add(1)
	go printNumbers(&wg)
	wg.Wait()
}

//В этом примере создается горутина для выполнения функции printNumbers, и используется WaitGroup для ожидания завершения горутины.
//
//Таким образом, green threads в Go, реализованные через горутины, предоставляют мощный и эффективный способ управления concurrency в приложениях.
