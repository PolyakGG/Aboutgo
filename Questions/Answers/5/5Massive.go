//Массив представляет собой набор значений, относящихся к
//одному типу. Представьте себе таблетницу — вы можете класть
//и доставать таблетки в любое отделение, но при этом ее удобно
//переносить как единое целое

//Значения, хранящиеся в массиве, называются элементами.
//Вы можете создать массив строк, массив логических значений
//или массив любого другого типа Go (даже массив массивов).
//Весь массив можно сохранить в одной переменной, а затем
//обратиться к любому нужному элементу
// var myArray [4]//кол-во элементов string // - Тип элементов

// Массив содержит заранее заданное количество элементов,
//а его размер не может увеличиваться или уменьшаться. Чтобы
//объявить переменную для хранения массива, следует указать
//количество хранящихся в нем элементов в квадратных скобках
//([]), а затем тип элементов в массиве.

//Чтобы присвоить значения элементам массива или прочитать
//их позднее, необходимо каким-то образом указать, какой элемент вам нужен. Элементы в массиве нумеруются, начиная с 0.
//Номер массива называется его индексом.
// Индекс задается в квадратных скобках.

// Массив целых чисел:
// var primes [5]int - Создается массив из 5 числе
// primes[0] = 2 -Присваивается значение первого элемента
// primes[1] = 3 - Присваивается значение второго элемента
// fmt.Println(primes[0]) -Выводится значение первого элемента

// Массив значений time.Time:

//var dates [3]time.Time - //Создается массив из трех значений Time.
//dates[0] = time.Unix(1257894000, 0) - Присваивается значение первого элемента.
//dates[1] = time.Unix(1447920000, 0) - Присваивается значение второго элемента.
//dates[2] = time.Unix(1508632200, 0) - Присваивается значение третьего элемента.
//fmt.Println(dates[1]) - Выводится второй элемент.

// Нулевые значения в массивах

//Как и в случае с переменными, при создании массивов все содержащиеся в них
//значения инициализируются нулевым значением для типа, содержащегося в массиве. Так массив значений int по умолчанию заполняется нулями
// С другой стороны, нулевым значением для строк является пустая строка, так
//что массив строковых значений по умолчанию заполняется пустыми строками:

//Нулевые значения позволяют безопасно выполнять операции с элементами
//массивов, даже если им не были присвоены значения. Например, в следующем
//массиве хранятся целочисленные счетчики. Любой элемент можно увеличить
//на 1 даже без предварительного присваивания значения, потому что мы знаем,
//что все значения счетчиков начинаются с 0.

//При создании массива все содержащиеся
//в нем элементы инициализируются нулевым
//значением для типа, хранящегося в массиве.

// Литералы массивов
//Если вам заранее известны значения, которые должны храниться в массиве, вы можете инициализировать массив этими значениями в форме литерала массива.
//Литерал массива начинается как тип массива — с количества элементов в квадратных скобках,
//за которым следует тип элементов. Далее в фигурных скобках идет список исходных
//значений элементов массива. Значения элементов должны разделяться запятыми.

//[3]int{9,18,27}
//[3] - Кол-во элементов в массиве
//int - тип элементов в массиве
//{9,18,27} - Список значений разделенных запятыми

//Литералы массивов также Литералы массивов также позволяют использовать короткие объявления
//переменных с помощью := .

// notes := [7]string{"do", "re", "mi", "fa", "so", "la", "ti"} - Короткое объявление переменной.
// primes := [5]int{2, 3, 5, 7, 11} - Короткое объявление переменной.

// Литералы массивов могут распространяться на несколько строк, но перед каждым
//переносом строки в коде должна стоять запятая. Запятая даже должна стоять после
//последнего элемента в литерале массива, если за ним следует перенос строки.

//text := [3]string{ - Все это один массив.
//"This is a series of long strings",
//"which would be awkward to place",
//"together on a single line", - Запятая в конце, обязательна.
//}

package main

import "fmt"

func main() {
	var numbers [3]int
	numbers[0] = 42
	numbers[2] = 108
	var letters = [3]string{"a", "b", "c"}
	fmt.Printf("%#v\n", numbers)
	fmt.Printf("%#v\n", letters)

}

//Обращение к элементам массива в цикле
//Вы не обязаны явно записывать целочисленные индексы элементов массивов, к которым обращаетесь в своем коде.
//В качестве индекса также можно использовать значение целочисленной переменной.

//notes := [7]string{"do", "re", "mi", "fa", "so", "la", "ti"}
//index := 1 - Выводит элемент массива с индексом 1.
//fmt.Println(index, notes[index])
//index = 3 - Выводит элемент массива с индексом 3.
//fmt.Println(index, notes[index])

// Это означает, что элементы массивов можно перебирать в цикле for.
//Цикл перебирает индексы массива, а переменная цикла используется
//для обращения к элементу с текущим индексом.

// notes := [7]string{"do", "re", "mi", "fa", "so", "la", "ti"}
// for i := 0; i <= 2; i++ { - Перебирает индексы 0, 1 и 2.
// fmt.Println(i, notes[i]) - 0 do 1 re 2 mi
// }

// Попытка обратиться к индексу за пределами массива приводит к
//панике — ошибке, происходящей во время выполнения программы (а не на
//стадии компиляции).

// Проверка длины массива функцией «len»
//Написание циклов, которые ограничиваются только правильными индексами, сопряжено с определенным риском ошибок. К счастью, есть пара приемов, которые
//упрощают этот процесс.
//Во-первых, вы можете проверить фактическое количество элементов в массиве перед
//обращением к элементу. Для этого можно воспользоваться встроенной функцией len,
//которая возвращает длину массива (количество содержащихся в нем элементов).

// notes := [7]string{"do", "re", "mi", "fa", "so", "la", "ti"}
//fmt.Println(len(notes)) - Выводит длину массива «notes».
//primes := [5]int{2, 3, 5, 7, 11}
//fmt.Println(len(primes)) -Выводит длину массива «primes».

// Безопасный перебор массивов в цикле «for...range»
//for index, value := range myArray {
//// Блок цикла.
//}
//for index, - Переменная, в которой будет сохраняться индекс каждого элемента.
//value - Переменная, в которой будет сохраняться значение каждого элемента.
//range - Ключевое слово «range».
//myArray - Обрабатываемый массив

//Эта форма цикла for не содержит запутанных выражений инициализации, условия
//и завершения. А поскольку значение элемента автоматически присваивается переменной, риск обращения к недействительному индексу массива исключен. Форма
//цикла for с range читается безопаснее и проще, поэтому именно она чаще всего
//встречается при работе с массивами и другими коллекциями.

//package main
//
//import "fmt"
//
//func main() {
//	notes := [7]string{"do", "re", "mi", "fa", "so", "la", "ti"}
//	for index, note := range notes {
//		fmt.Println(index, note)
//	}
//}
//Вывод:
//0 do
//1 re
//2 mi
//3 fa
//4 so
//5 la
//6 ti

// Пустой идентификатор в циклах «for...range»
//Как обычно, Go требует, чтобы каждая объявленная переменная использовалась
//в программе. Если отказаться от использования переменной index в цикле for...
//range, вы получите сообщение об ошибке:
//Если вам не нужен индекс каждого элемента массива, присвойте его пустому идентификатору:
//for _, note := range notes {
