// В языке Go каналы являются мощным средством для синхронизации и передачи данных между горутинами. Давайте рассмотрим каждый из упомянутых аспектов более подробно.
//
// Устройство каналов
// Каналы в Go реализованы как кольцевые буферы, что позволяет эффективно передавать данные между горутинами. Они могут быть буферизированными и небуферизированными.
//
// Буферизированные и небуферизированные каналы
// Буферизированные каналы позволяют отправлять несколько значений до блокировки. Это значит, что отправитель может продолжать отправлять данные до тех пор, пока буфер не заполнится.
// Небуферизированные каналы блокируют отправителя до тех пор, пока получатель не получит значение. Это обеспечивает строгую синхронизацию между отправителем и получателем.
// Пример буферизированного канала:
package main

import (
	"fmt"
)

func main() {
	ch := make(chan int, 2) // Создаем буферизированный канал с буфером на 2 значения

	ch <- 1
	ch <- 2

	fmt.Println(<-ch)
	fmt.Println(<-ch)
}

// Пример небуферизированного канала:
//
//package main
//
//import (
//    "fmt"
//)
//
//func main() {
//    ch := make(chan int) // Создаем небуферизированный канал
//
//    go func() {
//        ch <- 1
//    }()
//
//    fmt.Println(<-ch)
//}

//Паттерны использования
//Pipe: Связывание нескольких горутин через каналы.Pipe (Связывание нескольких горутин через каналы)
//
//В этом паттерне несколько горутин связаны между собой через каналы, образуя "трубу".
//Каждая горутина читает данные из канала, обрабатывает их и отправляет результат в следующий канал.
//Это позволяет разделить сложную задачу на несколько более простых этапов, каждый из которых выполняется отдельной горутиной.
//package main
//
//func main() {
//	ch1 := make(chan int)
//	ch2 := make(chan int)
//
//	go func() {
//		// горутина 1 читает из ch1 и отправляет результат в ch2
//		for n := range ch1 {
//			ch2 <- n * 2
//		}
//	}()
//
//	go func() {
//		// горутина 2 читает из ch2 и печатает результат
//		for n := range ch2 {
//			fmt.Println(n)
//		}
//	}()
//
//	// отправляем данные в ch1
//	for i := 0; i < 10; i++ {
//		ch1 <- i
//	}
//
//	close(ch1)
//}
//
//Fan-in (Мультиплексирование нескольких источников в один канал)
//
//В этом паттерне несколько горутин отправляют данные в один канал. Это позволяет объединить данные из нескольких источников в один поток.
//func main() {
//	ch := make(chan int)
//
//	go func() {
//		// горутина 1 отправляет данные в ch
//		for i := 0; i < 10; i++ {
//			ch <- i
//		}
//	}()
//
//	go func() {
//		// горутина 2 отправляет данные в ch
//		for i := 10; i < 20; i++ {
//			ch <- i
//		}
//	}()
//
//	// читаем данные из ch
//	for n := range ch {
//		fmt.Println(n)
//	}
//}
//
////Fan-out: Разветвление одного канала на несколько горутин.
//Fan-out (Разветвление одного канала на несколько горутин)
//
//В этом паттерне один канал отправляет данные в несколько горутин.
//Это позволяет разделить данные на несколько потоков и обработать их параллельно.
//func main() {
//	ch := make(chan int)
//
//	go func() {
//		// горутина 1 читает из ch и печатает результат
//		for n := range ch {
//			fmt.Println("goroutine 1:", n)
//		}
//	}()
//
//	go func() {
//		// горутина 2 читает из ch и печатает результат
//		for n := range ch {
//			fmt.Println("goroutine 2:", n)
//		}
//	}()
//
//	// отправляем данные в ch
//	for i := 0; i < 10; i++ {
//		ch <- i
//	}
//
//	close(ch)
//}
//
//Невалидные операции
//Закрытие закрытого канала: Попытка закрыть уже закрытый канал вызовет панику.
//Отправка/получение из закрытого канала: Отправка в закрытый канал вызовет панику. Получение из закрытого канала вернет нулевое значение типа канала и false.
//Пример:
//
//package main
//
//import (
//    "fmt"
//)
//
//func main() {
//    ch := make(chan int)
//    close(ch)
//
//    // Получение из закрытого канала
//    v, ok := <-ch
//    fmt.Println(v, ok) // 0 false
//
//    // Отправка в закрытый канал вызовет панику
//    // ch <- 1
//
//    // Закрытие закрытого канала вызовет панику
//    // close(ch)
//}
//Copy
//Insert
//
//Эти примеры и объяснения помогут вам лучше понять работу каналов в Go и их использование в различных паттернах.
