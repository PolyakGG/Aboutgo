Конспект по темам для изучения Go (Golang):

// TODO 1. Concurrency в Go
// todo Горутина (Goroutine):
Легковесная нить исполнения, которая управляется планировщиком Go.
// todo Сопрограмма (Coroutine), Корутина (Coroutine), Горутина (Goroutine), Файбры (Fibers), Грин треды (Green Threads):
// todo Виртуальные потоки, управляемые на уровне приложения, а не операционной системы.
Преимущества горутин:
Меньшее потребление ресурсов по сравнению с потоками ОС.
Простота создания и масштабирования.
Контекст горутины:
Минимальный контекст исполнения, включающий стек, указатели и локальные переменные.
Контекст свитчинг:
Переключение между горутинами требует меньше ресурсов и времени, чем переключение потоков ОС.
Примитивы синхронизации:

Мьютекс (Mutex):
Примитив для обеспечения взаимного исключения при доступе к разделяемым ресурсам.
Когда горутина вызывает Lock, она блокируется до тех пор, пока мьютекс не будет освобожден.
Остальные примитивы:
RWMutex: Разделяемый мьютекс для чтения и записи.
WaitGroup: Ожидание завершения группы горутин.
Cond: Условная переменная для оповещения горутин о состоянии.
Проблемы concurrency программирования:

//todo Дедлоки (Deadlocks):
Ситуации, когда две или более горутины ждут освобождения ресурса, удерживаемого другой.
//todo Лайфлоки (Livelocks):
Ситуации, когда горутины постоянно изменяют свое состояние, не достигая прогресса.
// todo Рейс-кондишен (Race Condition):
Проблема, возникающая при неконтролируемом доступе к разделяемым данным из нескольких горутин.
Data Races:
Конфликт доступа к памяти между горутинами.


2. Планировщик Go
//todo Модели многозадачности:

Кооперативная модель:
Горутины передают управление друг другу добровольно.
//todo Вытесняющая модель:
Планировщик сам решает, когда прервать горутину для переключения.
Планировщик Go использует вытесняющую многозадачность.
Внутреннее устройство планировщика:

GMP модель:
G (Goroutine): Горутины.
M (Machine): Потоки ОС, которые исполняют горутины.
P (Processor): Абстракция, контролирующая выполнение горутин.
Взаимодействие:
Горутины распределяются между процессорами, которые исполняются на машинах (потоках).
//todo Очереди:

Локальная и глобальная очередь:
Локальная очередь содержит горутины, привязанные к процессору.
Глобальная очередь используется для баланса нагрузки.
Work-stealing:
Механизм, при котором процессор может "украсть" горутину из локальной очереди другого процессора.
Sysmon и Netpoller:
Sysmon: Фоновая горутина, управляющая системными операциями.
Netpoller: Управляет I/O операциями.
Взаимодействие с системными вызовами:

При вызове системного вызова горутина может быть приостановлена, пока не завершится операция.



3. Каналы в Go
Устройство каналов:
Каналы реализованы как кольцевые буферы с очередями для передачи данных между горутинами.
Буферизированные и небуферизированные каналы:
Буферизированные: Позволяют отправлять несколько значений до блокировки.
Небуферизированные: Блокируют отправителя до получения значения.
Паттерны использования:
Pipe: Связывание нескольких горутин через каналы.
Fan-in: Мультиплексирование нескольких источников в один канал.
Fan-out: Разветвление одного канала на несколько горутин.
Невалидные операции:
Закрытие закрытого канала, отправка/получение из закрытого канала.



4. Память и GC (Garbage Collector) в Go
Горутины и стеки:

Начальный размер стека горутины мал и динамически увеличивается.
Contiguous stack: Непрерывный стек.
Segmented stack: Деление стека на сегменты для оптимизации.
Блокатор Go: Аллокатор памяти для горутин.

Garbage Collector:
Модель: Mark-and-sweep с конкуррентной паузой.
Фазы GC:
Mark: Обнаружение "живых" объектов.
Sweep: Освобождение памяти.
Управление GC:
Настройка частоты срабатывания, контроль задержек.



5. Слайсы и мапы в Go
Слайсы и массивы:

Слайс: Ссылочный тип данных, динамически изменяющий размер.
Массив: Фиксированный размер.
Стратегия расширения: Слайсы удваивают размер при достижении предела.
Мапы:

Реализованы через хеш-таблицы.
Хеш-коллизия: Конфликт значений хеш-функции.
Load factor: Коэффициент заполнения.
Резолвинг коллизий: Открытая адресация, цепочки.



6. Строки в Go
Устройство строк:
Строки неизменяемы (immutable).
Конкатенация создает новую строку.
Подсчет символов:
Используются руны (rune) для представления символов Unicode.
Итерация:
Range: Возвращает индексы и руны.
Индексирование: Позволяет доступ к байтам строки.




7. ООП в Go
Реализация ООП:
В Go нет классов, но есть структуры и интерфейсы.
Утиная типизация: Тип определяется по поведению (методам).
Интерфейсы: Контракты для структур.
Type assertion: Проверка типа интерфейса в runtime.
Пустые интерфейсы: Могут хранить значение любого типа.




8. Указатели и контексты
Указатели и контексты:
Контексты: Используются для передачи дедлайнов, отмен и других сигналов.
Grace fault: Контекстные ошибки и их обработка.
Рефлексия и дженерики:
Рефлексия: Работа с типами в runtime.
Дженерики: Универсальные типы, появившиеся в последних версиях Go.






