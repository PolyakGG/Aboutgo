package Coroutine

// Корутины

//В отличие от подпрограмм, корутины выполняются конкурентно на разных стеках, но все равно верно, что одновременно
//выполняется только одна функция, а ее вызывающая сторона ждет.
// Корутины обеспечивают конкурентность без параллелизма: когда выполняется одна корутина, возобновляющая ее или уступающая ей не выполняется.
//Поскольку корутины выполняются по очереди и переключаются только в определенных точках программы, корутины могут обмениваться данными между собой без гонок.
//Поскольку планирование осуществляется в явном виде (без какого-либо прерывания) и полностью без участия операционной системы, переключение корутины занимает не более десяти наносекунд, а обычно и того меньше.
//Запуск и завершение работы также значительно дешевле, чем у потоков.
//Корутины являются полезным строительным блоком для написания программ, которым нужна конкурентность для структурирования программы, но не для параллелизма.

//Корутины - это паттерн конкурентности, который не обслуживается напрямую существующими библиотеками конкурентности Go.
//Горутины часто достаточно близки, но, как мы видели, это не одно и то же, и иногда это различие имеет значение.

//Например, несколько упрощенный итератор деревьев в Go может выглядеть следующим образом:
//
//func (t *Tree[V]) All(yield func(v V)) {
//	if t != nil {
//		t.left.All(yield)
//		yield(t.value)
//		t.right.All(yield)
//	}
//}

//Сегодня этот итератор может быть вызван как:
//
//t.All(func(v V) {
//	fmt.Println(v)
//})

//и, возможно, его вариант может быть вызван в будущей версии Go как:
//
//for v := range t.All {
//	fmt.Println(v)
//}
