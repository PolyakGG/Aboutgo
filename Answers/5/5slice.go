// Оказывается, в Go существует структура данных, в которую можно
//добавлять новые значения, — она называется сегментом. Как и
//массив, сегмент состоит из нескольких элементов, относящихся
//к одному типу. В отличие от массивов, существуют функции, позволяющие добавлять новые элементы в конец сегмента.
//Чтобы объявить тип переменной для хранения сегмента, поставьте
//пустую пару квадратных скобок — за ней следует тип элементов,
//которые будут храниться в сегменте.

//var mySlice []string
//
//Фактически это уже знакомый синтаксис объявления массива,
//только без указания размера.
// var myArray [5]int - Массив
// var mySlice []int - Сегмент

// В отличие от переменных для массивов, объявление переменной
//для сегмента не приводит к автоматическому созданию сегмента.
//Для этого следует вызвать встроенную функцию make. Функции
//передается тип создаваемого сегмента (он должен соответствовать
//типу переменной, которой вы собираетесь присвоить сегмент)
//и длина сегмента при создании.
//var notes []string - Объявление переменной для сегмента.
//notes = make([]string, 7) - Создание сегмента из 7 строк.
// Для присваивания и чтения элементов созданного сегмента
//используется тот же синтаксис, который использовался бы для массива.
//notes[0] = "do" - Присваивает значение первому элементу.
//notes[1] = "re" - Присваивает значение второму элементу.
//notes[2] = "mi" - Присваивает значение третьему элементу.
//fmt.Println(notes[0]) - Выводит первый элемент.
//fmt.Println(notes[1]) - Выводит второй элемент.

//Объявлять переменную и создавать сегмент по отдельности
//необязательно; если вы воспользуетесь коротким объявлением
//переменной, то тип переменной будет определен автоматически.

//primes := make([]int, 5)
//primes[0] = 2
//primes[1] = 3
//fmt.Println(primes[0])

//Встроенная функция len для сегментов работает так же, как и для массивов.
//Передайте len сегмент, и функция вернет его длину в виде целого числа.
//notes := make([]string, 7)
//primes := make([]int, 5)
//fmt.Println(len(notes)) - 7
//fmt.Println(len(primes)) - 5

//Циклы for и for...range работают с сегментами точно так же, как и с массивами:

// letters := []string{"a", "b", "c"}
//for i := 0; i < len(letters); i++ {
//fmt.Println(letters[i]) - a b c
//}
//for _, letter := range letters {
//fmt.Println(letter) - a b c
//}

//Как и с массивами, если вы заранее знаете, какими значениями должен быть заполнен сегмент в исходном
//состоянии, то можете инициализировать сегмент этими значениями при помощи литерала сегмента.
//Литерал сегмента очень похож на литерал массива, но если литерал массива содержит длину массива в
//квадратных скобках, у литерала сегмента квадратные скобки пусты. За пустыми скобками следует тип
//элементов, которые будут храниться в сегменте, и список исходных значений всех элементов, заключенный в фигурные скобки.

package main

import "fmt"

func main() {
	numbers := make([]float64, 3)
	numbers[0] = 19.7
	numbers[2] = 25.2
	for i, number := range numbers {
		fmt.Println(i, number)
	}
	var letters = []string{"a", "b", "c"}
	for i, letter := range letters {
		fmt.Println(i, letter)
	}
}

// Погодите! Похоже, что сегменты могут делать все,
//что делают массивы, и в них можно добавлять элементы. Тогда почему бы не ограничиться сегментами
//и не забыть про эту ерунду с массивами?

//Потому что сегменты построены на основе массивов.
//И вы не сможете понять, как работают сегменты,
//не понимая массивы. Сейчас мы покажем почему.

// Оператор сегмента
//Каждый массив существует на основе базового массива. Данные сегмента
//на самом деле хранятся в базовом массиве, а сегмент всего лишь предоставляет «окно» для работы с некоторыми (или всеми) элементами массива.
//Когда вы используете функцию make или литерал сегмента для создания
//сегмента, базовый массив при этом создается автоматически (и вы не
//можете обратиться к нему иначе как через сегмент). Но вы также можете
//создать массив самостоятельно, а затем создать сегмент на основе этого
//массива при помощи оператора сегмента.
// mySlice := myArray[1:3] - [1: - Индекс массива с которого должен начинаться элемент
//                           :3] -Индекс перед которым завершается сегмент.
//

// Оператор сегмента напоминает синтаксис обращения к отдельному элементу или сегменту массива, не считая того, что
//он имеет два индекса: индекс, с которого должен начинаться
//сегмент, и индекс, перед которым сегмент завершается.

// underlyingArray := [5]string{"a", "b", "c", "d", "e"}
//slice1 := underlyingArray[0:3]
//fmt.Println(slice1) - Элементы underlyingArray с 0 по 2. - [a b c]

// Обратите внимание: мы неоднократно подчеркиваем, что второй
//индекс определяет позицию, перед которой завершается сегмент.
//Другими словами, сегмент должен включать все элементы до второго
//индекса, не включая его. Если использовать оператор сегмента в конструкции underlyingArray[i:j], полученный сегмент будет содержать элементы от underlyingArray[i] до underlyingArray[j-1].

// underlyingArray := [5]string{"a", "b", "c", "d", "e"}
//i, j := 1, 4
//slice2 := underlyingArray[i:j]
//fmt.Println(slice2)
// Элементы underlyingArray с 1 по 3 - [b c d]

// Если вы хотите, чтобы сегмент включал последний элемент
//базового массива, укажите в операторе сегмента второй индекс
//на 1 больше последнего индекса массива.

// У оператора сегмента предусмотрены значения по умолчанию как для начального, так и для конечного индексов. Если
//начальный индекс не указан, будет использовано значение 0
//(первый элемент массива).
//underlyingArray := [5]string{"a", "b", "c", "d", "e"}
//slice4 := underlyingArray[:3]
//fmt.Println(slice4) -[a b c]

// А если не указан конечный индекс, то в сегмент включаются
//все элементы от начального индекса и до конца базового
//массива.

//underlyingArray := [5]string{"a", "b", "c", "d", "e"}
//slice5 := underlyingArray[1:]
//fmt.Println(slice5) - [b c d e]

// Базовые массивы

// Как упоминалось ранее, сам сегмент не содержит данных, это
//всего лишь «окно» для просмотра элементов базового массива.
//Сегмент можно представить себе как микроскоп, направленный
//на определенную часть предметного стекла (базовый массив).

//Когда вы берете сегмент базового массива, то «видите» только
//ту часть элементов массива, которая видна через этот сегмент.

// array1 := [5]string{"a", "b", "c", "d", "e"}
//slice1 := array1[0:3]
//fmt.Println(slice1) - [a b c]

//array2 := [5]string{"f", "g", "h", "i", "j"}
//slice2 := array2[2:5]
//fmt.Println(slice2) - [h i j]

// Несколько сегментов могут существовать на основе одного базового массива.
//В этом случае каждый сегмент становится «окном» для отдельного подмножества элементов массива. Сегменты даже могут перекрываться!

// array3 := [5]string{"a", "b", "c", "d", "e"}
//slice3 := array3[0:3]
//slice4 := array3[2:5]
//fmt.Println(slice3, slice4) - [a b c] [c d e]

//При изменении базового массива изменяется сегмент

//А теперь один нюанс: поскольку сегмент является всего лишь «окном»
//для работы с содержимым массива, в случае изменения базового массива
//эти изменения также отразятся в сегменте!

//array1 := [5]string{"a", "b", "c", "d", "e"}
//slice1 := array1[0:3]
//array1[1] = "X"
//fmt.Println(array1) - [a X c d e]
//fmt.Println(slice1) - [a X c]

// Присваивание нового значения элементу сегмента приводит
//к изменению соответствующего элемента в базовом массиве.

//Если на один и тот же базовый массив указывают несколько
//сегментов, то и изменения элементов массива будут видны
//во всех сегментах.

// Из-за этих потенциальных проблем обычно рекомендуется
//создавать сегменты с использованием make или литерала
//сегмента (вместо того, чтобы создать массив и применять к
//нему оператор сегмента). С make и литералами сегментов вам
//никогда не приходится иметь дела с базовым массивом.

// В Go существует встроенная функция append, которая получает сегмент и одно или несколько значений, которые
//присоединяются в конец сегмента. Функция возвращает новый, расширенный сегмент со всеми элементами исходного
//сегмента и новыми элементами, добавленными в его конец.

// slice := []string{"a", "b"} - Создание сегмента
//fmt.Println(slice, len(slice)) - [a b] 2
//slice = append(slice, "c") - Элемент присоединяется в конец сегмента.Возвращаемое значение «append» присваивается той же переменной slice.
//fmt.Println(slice, len(slice)) - [a b c] 3
//slice = append(slice, "d", "e") - Два элемента присоединяются в конец сегмента.
//fmt.Println(slice, len(slice)) [a b c d e] 5

// Вам не нужно следить за тем, по какому индексу присваиваются новые значения, или за чем-нибудь еще! Просто вызовите
//функцию append и передайте ей сегмент со значениями, которые добавляются в конец сегмента, и вы получите новый
//расширенный сегмент. Да, так просто!
//Хотя нужно учитывать один момент...

// Базовый массив сегмента не может увеличиваться в размерах. Если в массиве не остается места для добавления элементов, все элементы копируются в новый, больший массив, а сегмент обновляется, чтобы
//он базировался на новом массиве. Но поскольку все это происходит где-то за кулисами внутри функции
//append, невозможно простым способом определить, имеет ли возвращенный сегмент тот же базовый
//массив, как и переданный сегмент, или другой. Если в программе будут оставаться оба сегмента, это может
//привести к непредсказуемому поведению.

// s1 := []string{"s1", "s1"}
//s2 := append(s1, "s2", "s2")
//s3 := append(s2, "s3", "s3")
//s4 := append(s3, "s4", "s4")
//fmt.Println(s1, s2, s3, s4)
//s4[0] = "XX" - Когда значение присваивается элементу сегмента s4, мы видим, что изменения отражаются в s3, потому что s4 и s3 используют один и тот же базовый массив. Однако изменения не отражаются в s2 или s1, потому что они используют другой базовый массив.
//fmt.Println(s1, s2, s3, s4)
// [s1 s1] [s1 s1 s2 s2] [s1 s1 s2 s2 s3 s3] [s1 s1 s2 s2 s3 s3 s4 s4]
// [s1 s1] [s1 s1 s2 s2] [XX s1 s2 s2 s3 s3] [XX s1 s2 s2 s3 s3 s4 s4]

// Как и в случае с массивами, при обращении к элементу сегмента, которому
//не было присвоено значение, вы получите нулевое значение для этого типа:
