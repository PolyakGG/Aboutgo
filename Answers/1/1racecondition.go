// Race Condition (состояние гонки) возникает, когда два или более горутины (goroutines) обращаются к одной и той же переменной одновременно, и хотя бы одна из них изменяет значение этой переменной.
// Это может привести к непредсказуемому поведению программы.
//
// Приведу пример состояния гонки в Go:
package main

import (
	"fmt"
	"sync"
)

func main() {
	var counter int
	var wg sync.WaitGroup

	// Запускаем 1000 горутин
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			counter++
		}()
	}

	wg.Wait()
	fmt.Println("Counter:", counter)
}

// В этом примере 1000 горутин одновременно увеличивают значение переменной counter. Поскольку операция увеличения (counter++) не является атомарной, это может привести к состоянию гонки.
// В результате значение переменной counter может быть меньше 1000, так как некоторые инкременты могут быть потеряны из-за одновременного доступа к переменной.
//
// Для устранения состояния гонки можно использовать мьютекс (mutex):package main
//package main
//
//import (
//	"fmt"
//	"sync"
//)
//
//func main() {
//	var counter int
//	var wg sync.WaitGroup
//	var mu sync.Mutex
//
//	// Запускаем 1000 горутин
//	for i := 0; i < 10; i++ {
//		wg.Add(1)
//		go func() {
//			defer wg.Done()
//			mu.Lock()
//			counter++
//			fmt.Printf("Counter: %d\n", counter)
//			mu.Unlock()
//		}()
//	}
//
//	wg.Wait()
//	fmt.Println("Counter:", counter)
//}

//В этом исправленном примере используется мьютекс mu для защиты доступа к переменной counter.
//Это гарантирует, что только одна горутина может изменять значение переменной counter в любой момент времени, предотвращая состояние гонки.
//Data Races:
//Конфликт доступа к памяти между горутинами.
//В этом примере несколько горутин одновременно увеличивают значение переменной counter.
//Это приводит к конфликту доступа к памяти, так как несколько горутин одновременно читают и записывают значение переменной counter.
