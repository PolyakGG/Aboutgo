// Планировщик Go (Goroutine Scheduler) использует вытесняющую многозадачность для управления выполнением горутин.
// Это означает, что планировщик сам решает, когда прервать выполнение одной горутины и переключиться на другую, чтобы обеспечить равномерное распределение времени процессора между всеми горутинами.
//
// Как это работает
// Горутины: Горутины — это легковесные потоки, которые управляются планировщиком Go. Они запускаются с помощью ключевого слова go.
// Планировщик: Планировщик Go решает, когда и какая горутина должна выполняться. Он использует несколько стратегий для этого, включая тайм-ауты и системные вызовы.
// Многопоточность: Планировщик Go может использовать несколько операционных системных потоков (OS threads) для выполнения горутин, что позволяет эффективно использовать многоядерные процессоры.
// Пример
// Рассмотрим простой пример, где несколько горутин выполняются параллельно:
//package main
//
//import (
//	"fmt"
//	"time"
//)
//
//func printNumbers() {
//	for i := 1; i <= 5MassiveSlice; i++ {
//		fmt.Printf("Number: %d\n", i)
//		time.Sleep(100 * time.Millisecond) // Симуляция работы
//	}
//}
//
//func printLetters() {
//	for ch := 'a'; ch <= 'e'; ch++ {
//		fmt.Printf("Letter: %c\n", ch)
//		time.Sleep(150 * time.Millisecond) // Симуляция работы
//	}
//}
//
//func main() {
//	go printNumbers()
//	go printLetters()
//
//	// Даем время горутинам завершить выполнение
//	time.Sleep(1 * time.Second)
//}

//Объяснение
//Запуск горутин: В функции main мы запускаем две горутины с помощью ключевого слова go: printNumbers и printLetters.
//Выполнение горутин: Обе горутины начинают выполняться параллельно. Планировщик Go решает, когда переключаться между ними.
//Симуляция работы: В каждой горутине используется time.Sleep, чтобы симулировать выполнение работы и дать планировщику возможность переключиться на другую горутину.
//Завершение: В конце функции main используется time.Sleep, чтобы дать время горутинам завершить выполнение перед завершением программы.
//Вытесняющая многозадачность
//Планировщик Go использует вытесняющую многозадачность, что означает, что он может прервать выполнение одной горутины и переключиться на другую в любой момент времени.
//Это позволяет эффективно использовать ресурсы процессора и обеспечивать равномерное распределение времени выполнения между горутинами.
//
//Заключение
//Планировщик Go автоматически управляет выполнением горутин, используя вытесняющую многозадачность.
//Это делает написание многозадачных программ в Go простым и эффективным, так как разработчику не нужно вручную управлять переключением контекста между горутинами.

// Кооперативная модель многозадачности предполагает, что задачи (в данном случае горутины) сами решают, когда передать управление другим задачам.
// Это отличается от вытесняющей многозадачности, где планировщик операционной системы решает, когда приостановить выполнение одной задачи и начать выполнение другой.
//
// В языке Go горутины работают по вытесняющей модели, но для понимания кооперативной модели можно рассмотреть пример:
package main

import (
	"fmt"
	"time"
)

func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		fmt.Printf("Worker %d started job %d\n", id, j)
		time.Sleep(time.Second) // Симуляция работы
		fmt.Printf("Worker %d finished job %d\n", id, j)
		results <- j * 2
	}
}

func main() {
	const numJobs = 5
	jobs := make(chan int, numJobs)
	results := make(chan int, numJobs)

	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	for j := 1; j <= numJobs; j++ {
		jobs <- j
	}
	close(jobs)

	for a := 1; a <= numJobs; a++ {
		<-results
	}
}

//В этом примере:
//
//Функция worker представляет собой горутину, которая получает задания из канала jobs и отправляет результаты в канал results.
//В main создаются каналы jobs и results.
//Запускаются три горутины worker.
//В канал jobs отправляются задания, после чего канал закрывается.
//Основная горутина ожидает завершения всех заданий, считывая результаты из канала results.
//Этот пример демонстрирует кооперативную модель, где несколько горутин работают вместе для выполнения заданий, используя каналы для координации.
