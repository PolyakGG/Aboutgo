// Иногда конкретный тип значения не важен. Вас не интересует,
//с чем вы работаете. Вы просто хотите быть уверены в том, что оно может
//делать то, что нужно вам. Тогда вы сможете вызывать для значения определенные методы. Неважно, с каким значением вы работаете — Pen или
//Pencil; вам просто нужно нечто, содержащее метод Draw. Именно эту задачу
//решают интерфейсы в языке Go. Они позволяют определять переменные и
//параметры функций, которые могут хранить любой тип при условии, что этот
//тип определяет некоторые методы.
//  Набор средств, предоставляемых программой для
//взаимодействия с ней, часто называется ее интерфейсом.

//В Go интерфейс определяется как набор методов, которые должны поддерживаться некоторыми значениями.
//Таким образом, интерфейс представляет набор действий, выполняемых с использованием типа.

//Определение типа интерфейса состоит из ключевого слова interface, за ним следуют фигурные скобки
//со списком имен методов, а также параметрами и возвращаемыми значениями, которые должны иметь
//эти методы.

// type myInterface interface {
// 	methodWithoutParameters()
// methodWithParameters(float64) - тип параметра[float64]
// methodWithReturnValue() string - тип возвращаемого значения	[string]

// Любой тип, который содержит все методы, перечисленные в определении интерфейса, называется поддерживающим этот интерфейс.
//Тип, поддерживающий интерфейс, может использоваться в любом
//месте, где должен использоваться этот интерфейс.

// Имена методов, типы параметров (если они есть) и типы возвращаемых значений (если они есть) должны совпадать с определениями
//в интерфейсе. Тип может содержать методы помимо тех, которые
//перечислены в интерфейсе, но в нем не могут отсутствовать такие
//методы, иначе тип не будет поддерживать интерфейс.
//Тип может поддерживать несколько интерфейсов, а интерфейс может
//(и обычно должен) поддерживаться несколькими типами.

// Приведенный ниже код создает небольшой экспериментальный пакет с именем mypkg. Он определяет тип интерфейса с именем MyInterface, содержащий три метода. Затем определяет тип
//с именем MyType, поддерживающий MyInterface.
//Для поддержки MyInterface необходимы три метода: MethodWithoutParameters,
//MethodWithParameter с параметром float64 и MethodWithReturnValue, возвращающий
//string.
//Затем объявляется другой тип MyType. Базовый тип MyType в данном случае неважен; используется int. Мы определили все методы MyType, необходимые для поддержки MyInterface, а также
//один дополнительный метод, который не является частью интерфейса.

package main

import "fmt"

type MyInterface interface { // - Объявление типа интерфейса.
	MethodWithoutParameters()      // -Тип поддерживает этот интерфейс, если содержит этот метод...
	MethodWithParameter(float64)   // - А так же этот метод с параметром float64.
	MethodWithReturnValue() string // -И этот метод с возвращаемым значением string
}
type MyType int // Объявление типа, поддерживающего myInterface

func (m MyType) MethodWithoutParameters() { // Первый обязательный метод.
	fmt.Println("MethodWithoutParameters called")
}
func (m MyType) MethodWithParameter(f float64) { // Второй обязательный метод (с параметром float64).
	fmt.Println("MethodWithParameter called with", f)
}
func (m MyType) MethodWithReturnValue() string { // Третий обязательный метод (с возвращаемым значением string).
	return "Hi from MethodWithReturnValue"
}
func (my MyType) MethodNotInInterface() { //Тип может поддерживать 	интерфейс даже в том случае, если содержит другие методы, не входящие в этот интерфейс.
	fmt.Println("MethodNotInInterface called")
}

// Многие другие языки требуют явно указать, что MyType поддерживает MyInterface.
//Но в Go это происходит автоматически. Если тип содержит все методы, объявленные в интерфейсе, то может находиться в любом месте, где должен использоваться
//этот интерфейс, без каких-либо дополнительных объявлений.

// Переменная, объявленная с типом интерфейса, может содержать любое значение, тип
//которого поддерживает этот интерфейс.

// Все типы, которые мы определяли в предшествующих главах.были конкретными. Конкретный тип определяет не только то,
//что могут делать его значения (то есть какие методы для них
//можно вызывать), но и то, чем они являются: он определяет
//базовый тип, используемый для хранения данных значения.

// Типы интерфейсов не описывают, чем значение является: они
//ничего не говорят о базовом типе или о том, как хранятся его
//данные. Они только описывают, что значение может делать,
//то есть какие методы оно содержит.

// Предположим, вы хотите написать короткую записку. В ящике
//стола у вас лежат значения нескольких конкретных типов:
//Карандаш, Ручка и Фломастер. Каждый из этих конкретных
//типов определяет метод Write, так что вас на самом деле
//не интересует, какой именно тип будет выбран. Вам нужен
//предмет, которым можно писать: тип интерфейса, который
//поддерживается любым конкретным типом с методом Write.

// Если у вас имеется переменная с типом интерфейса, она
//может принимать значения любого типа, поддерживающего
//интерфейс.
//Допустим, есть два типа, Whistle и Horn, каждый из которых содержит метод MakeSound. Мы можем создать интерфейс NoiseMaker, который представляет любой тип с
//методом MakeSound. Если объявить переменную toy с типом
//NoiseMaker, ей можно будет присваивать как значения
//Whistle, так и значения Horn. (Или любых других типов,
//которые будут объявлены позднее — при условии, что тип
//содержит метод MakeSound.)
//Затем можно будет вызвать метод MakeSound для любого
//значения, присвоенного переменной toy. И хотя мы точно
//не знаем, каким конкретным типом является значение переменной toy, мы знаем, что с ним можно делать: вызывать метод MakeSound. Если его тип не содержит метод MakeSound,
//то он не поддерживает интерфейс NoiseMaker, и значение
//нельзя будет присвоить переменной.

// package main
//import "fmt"
//type Whistle string
//func (w Whistle) MakeSound() {
//fmt.Println("Tweet!")
//}
//type Horn string
//func (h Horn) MakeSound() {
//fmt.Println("Honk!")
//}
//type NoiseMaker interface {
//MakeSound()
//}
//func main() {
//var toy NoiseMaker
//toy = Whistle("Toyco Canary")
//toy.MakeSound()
//toy = Horn("Toyco Blaster")
//toy.MakeSound()
//}

// Параметры функций также могут объявляться с типами Honk!
//интерфейсов. (В конце концов, параметры функций — это
//по сути те же переменные.) Если объявить функцию play,
//которая получает NoiseMaker, вы можете передать любое
//значение типа, содержащего метод MakeSound:

// func play(n NoiseMaker) {
//n.MakeSound()
//}
//func main() {
//play(Whistle("Toyco Canary"))
//play(Horn("Toyco Blaster"))
//}

// Вызывать можно только методы, определенные как часть интерфейса

// После того как значение будет присвоено переменной (или
//параметру метода) с типом интерфейса, для нее можно
//будет вызывать только те методы, которые определяются
//интерфейсом.
//Предположим, вы создали тип Robot, который в дополнение к методу MakeSound также содержит метод Walk. Мы
//добавляем вызов Walk в функцию play и передаем play
//новое значение Robot.
//Однако код не компилируется: в сообщении об ошибке говорится, что значения NoiseMaker не содержат метода Walk.
//Почему? Значения Robot содержат метод Walk; определение
//у вас прямо перед глазами!
//Но функции play передается не значение Robot,
//а NoiseMaker. Что, если play вместо него будет передано
//значение Whistle или Horn? У них нет методов Walk!
//Если у вас имеется переменная с типом интерфейса, то
//она гарантированно содержит только те методы, которые
//определены в интерфейсе. И только эти методы компилятор
//Go позволит вызвать. (Вообще говоря, вы можете получить
//информацию о конкретном типе значения для вызова более специализированных методов. Эта возможность будет
//рассмотрена позже.)

// package main
//import "fmt"
//type Whistle string
//func (w Whistle) MakeSound() {
//fmt.Println("Tweet!")
//}
//type Horn string
//func (h Horn) MakeSound() {
//fmt.Println("Honk!")
//}
//type Robot string
//func (r Robot) MakeSound() {
//fmt.Println("Beep Boop")
//}
//func (r Robot) Walk() {
//fmt.Println("Powering legs")
//}
//type NoiseMaker interface {
//MakeSound()
//}
//func play(n NoiseMaker) {
//n.MakeSound()
//n.Walk()
//}
//func main() {
//play(Robot("Botco Ambler"))
//}

// Обратите внимание: переменной с типом интерфейса можно
//присвоить тип, содержащий другие методы. Пока вы не вызываете эти другие методы, все будет работать.

// func play(n NoiseMaker) {
//n.MakeSound()
//}
//func main() {
//play(Robot("Botco Ambler"))
//}
