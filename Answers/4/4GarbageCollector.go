package main

//
//Garbage Collector:
//Модель: Mark-and-sweep с конкуррентной паузой.
//Фазы GC:
//Mark: Обнаружение "живых" объектов.
//Sweep: Освобождение памяти.
//Управление GC:
//Настройка частоты срабатывания, контроль задержек.
// Heap = Куча

// Сборщик мусора, он же GC (Garbage Collector) - это система, специально предназначенная для определения и освобождения динамически выделенной памяти.
//В Go используется алгоритм сборки мусора на основе трассировки и алгоритма пометок Mark and Sweep. (Три цвета. Серый, черный, белый)
//На этапе маркировки (mark) сборщик мусора помечает данные, которые активно используются приложением, в качестве живых (live heap).
//Затем на этапе очистки (sweep) GC проходит по всей памяти, которая не была помечена как живая, и переиспользует ее.
//Работа сборщика мусора не является бесплатной, поскольку он потребляет два важных ресурса системы: процессорное время и физическую память.
//Память в сборщике мусора содержит в себе живую память кучи (память, которая была помечена как живая в предыдущем цикле сборки мусора),
//новую память кучи (память кучи, которая еще не была проанализирована сборщиком мусора), а также память, используемую для хранения некоторых метаданных,
//которая обычно незначительна по сравнению с первыми двумя сущностями.
// Однако, в Go сборщик мусора все равно работает с некоторыми ограничениями, и несколько раз за цикл сборки мусора он полностью останавливает выполнение рабочего кода.
//В случае Go сборщик мусора не является полностью "stop-the-world"
//и выполняет большую часть своей работы, например, такую как разметка кучи (время выполнения которой пропорционально размеру кучи) параллельно с выполнением приложения.
//Как управлять сборщиком мусора?
//Существует параметр, который позволяет управлять сборщиком мусора в Go - это переменная окружения GOGC или ее функциональный аналог SetGCPercent из пакета runtime/debug.

import (
	"fmt"
	"os"
	"runtime/debug"
	"runtime/trace"
	"sync"
	"time"
)

const (
	NumWorkers    = 4     // Количество воркеров.
	NumTasks      = 500   // Количество задач.
	MemoryIntense = 10000 // Размер память затратной задачи (число элементов).
)

func main() {
	// Запись в trace файл.
	f, _ := os.Create("trace.out")
	trace.Start(f)
	defer trace.Stop()

	// Установка целевого процента сборщика мусора. По умолчанию 100%.
	debug.SetGCPercent(10)

	// Очередь задач и очередь результата.
	taskQueue := make(chan int, NumTasks)
	resultQueue := make(chan int, NumTasks)

	// Запуск воркеров.
	var wg sync.WaitGroup
	wg.Add(NumWorkers)
	for i := 0; i < NumWorkers; i++ {
		go worker(taskQueue, resultQueue, &wg)
	}

	// Отправка задач в очередь.
	for i := 0; i < NumTasks; i++ {
		taskQueue <- i
	}
	close(taskQueue)

	// Получение результатов из очереди.
	go func() {
		wg.Wait()
		close(resultQueue)
	}()

	// Обработка результатов.
	for result := range resultQueue {
		fmt.Println("Результат:", result)
	}

	fmt.Println("Готово!")
}

// Функция воркера.
func worker(tasks <-chan int, results chan<- int, wg *sync.WaitGroup) {
	defer wg.Done()

	for task := range tasks {
		result := performMemoryIntensiveTask(task)
		results <- result
	}
}

// performMemoryIntensiveTask функция требующая много памяти.
func performMemoryIntensiveTask(task int) int {
	// Создание среза большого размера.
	data := make([]int, MemoryIntense)
	for i := 0; i < MemoryIntense; i++ {
		data[i] = i + task
	}

	// Имитация временной задержки
	time.Sleep(10 * time.Millisecond)

	// Вычисление результата.
	result := 0
	for _, value := range data {
		result += value
	}
	return result
}
