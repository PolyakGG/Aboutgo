package Goroutine

//func main() {
//	ch := make(chan bool, 2Models.queue)
//	ch <- true
//	ch <- true
//	close(ch)
//
//	for i := 0; i < cap(ch)+1; i++ {
//		v, ok := <-ch
//		fmt.Println(v, ok)
//	}
//}

// В этом примере мы создаем канал с буфером из двух элементов, заполняем буфер, а затем закрываем его.
// true true
// true true
// false false
// Запуск программы показывает, что мы получаем первые два значения, отправленные в канал, а с третьей попытки канал выдаёт нам значения false и false.
// Первое значение false - это нулевое значение для типа канала, то есть false, так как канал имеет тип chan bool.
// Второе значение указывает на открытое состояние канала, которое теперь равно false, что означает, что канал закрыт.
// Канал будет продолжать сообщать эти значения бесконечно. В качестве эксперимента изменим этот пример так, чтобы прочитать из канала 100 раз.

// Способность определять, закрыт ли канал, является полезным свойством, оно используется в идиоме "range over channel" для выхода из цикла после того, как канал был исчерпан.
//
//	func main() {
//		ch := make(chan bool, 2Models.queue)
//		ch <- true
//		ch <- true
//		close(ch)
//
//		for v := range ch {
//			fmt.Println(v)
//		}
//	}
//
// Но по-настоящему проявляет себя в сочетании с select. Начнём с такого примера:
//func main() {
//	finish := make(chan bool)
//	var done sync.WaitGroup
//	done.Add(1)
//	go func() {
//		select {
//		case <-time.After(1 * time.Hour):
//		case <-finish:
//		}
//		done.Done()
//	}()
//	t0 := time.Now()
//	finish <- true
//	done.Wait()
//	fmt.Printf("Waited %v for goroutine to stop\n", time.Since(t0))
//}

// Однако в этой программе есть несколько проблем. Первая - канал finish не буферизован, поэтому посылка в finish может заблокироваться, если получатель забудет добавить finish в оператор select.
// Эту проблему можно решить, обернув посылку в блок select, чтобы сделать её неблокируемой, или сделав канал finish буферизованным. Однако если в канале finish будет прослушиваться множество горутин,
// то необходимо будет отслеживать это и не забывать отправлять нужное количество раз в канал finish. Это может оказаться сложной задачей, если вы не контролируете создание этих горутин;
// они могут создаваться в другой части вашей программы, возможно, в ответ на входящие запросы по сети.
// Хорошим решением этой проблемы является использование свойства, согласно которому закрытый канал всегда готов к приёму.
// Используя это свойство, мы можем переписать программу, включающую теперь 100 горутин, без необходимости отслеживать количество порождённых горутин или правильно определять размер канала finish:

//func main() {
//	const n = 100
//	finish := make(chan bool)
//	var done sync.WaitGroup
//	for i := 0; i < n; i++ {
//		done.Add(1)
//		go func() {
//			select {
//			case <-time.After(1 * time.Hour):
//			case <-finish:
//			}
//			done.Done()
//		}()
//	}
//	t0 := time.Now()
//	close(finish) // closing finish makes it ready to receive
//	done.Wait()   // wait for all goroutines to stop
//	fmt.Printf("Waited %v for %d goroutines to stop\n", time.Since(t0), n)
//}
//Что же здесь происходит? Как только канал finish закрывается, он становится готовым к приёму.
//Поскольку все горутины ожидают приёма либо по своему каналу time.After, либо по каналу finish, то оператор select завершается, и горутины выходят из системы после вызова done.Done(), чтобы деинкрементировать счетчик WaitGroup.
//Эта мощная идиома позволяет использовать канал для посылки сигнала неизвестному числу горутин, не зная о них ничего и не опасаясь возникновения блокировки (deadlock).

// Канал с нулевым значением всегда блокируется
// Нулевой канал; значение канала, которое не было инициализировано или было установлено в nil, всегда будет блокироваться. Например:
//package main
//
//func main() {
//	var ch chan bool
//	ch <- true // blocks forever
//}
//блокируется, так как ch - это nil и он никогда не будет готов к отправке. То же самое справедливо и для приёма:
//package main
//
//func main() {
//	var ch chan bool
//	<-ch // blocks forever
//}

// Это свойство может показаться неважным, но оно полезно, когда вы хотите использовать идиому закрытого канала для ожидания закрытия нескольких каналов.
//Например:
// WaitMany waits for a and b to close.
//func WaitMany(a, b chan bool) {
//	var aclosed, bclosed bool
//	for !aclosed || !bclosed {
//		select {
//		case <-a:
//			aclosed = true
//		case <-b:
//			bclosed = true
//		}
//	}
//}
// WaitMany() выглядит как хороший способ дождаться закрытия каналов a и b, но у него есть проблема. Допустим, канал a закрывается первым, тогда он всегда будет готов к приёму.
//Поскольку bclosed всё ещё ложно, программа может попасть в бесконечный цикл, не позволяя каналу b закрыться.
//
//Безопасный способ решения проблемы - использовать блокирующие свойства нулевого канала и переписать программу следующим образом:

//func WaitMany(a, b chan bool) {
//	for a != nil || b != nil {
//		select {
//		case <-a:
//			a = nil
//		case <-b:
//			b = nil
//		}
//	}
//}
//
//func main() {
//	a, b := make(chan bool), make(chan bool)
//	t0 := time.Now()
//	go func() {
//		close(a)
//		close(b)
//	}()
//	WaitMany(a, b)
//	fmt.Printf("Waited %v for WaitMany\n", time.Since(t0))
//}
//В переписанной WaitMany() мы обнуляем ссылку на a или b после того, как они получили значение. Когда нулевой канал является частью оператора select,
//он фактически игнорируется, поэтому обнуление a удаляет его из select, оставляя только b, который блокируется до тех пор, пока не будет закрыт (с выходом из цикла).
// Аксиомы канала
//Большинство начинающих программистов на Go быстро понимают, что канал - это очередь значений, и с пониманием относятся к тому, что операции с каналом могут блокироваться при его заполнении или опустошении.
//
//Рассмотрим четыре менее распространенных свойства каналов:
//
//Отправка в нулевой канал блокируется навсегда
//
//Получение из нулевого канала блокируется навсегда
//
//Отправка в закрытый канал приводит к панике
//
//Приём из закрытого канала немедленно возвращает нулевое значение

// Отправка в нулевой канал блокируется навсегда
// Первый случай, который несколько удивит новичков, - отправка в нулевой канал блокируется навсегда.
//
// В этом примере программа заблокируется, поскольку нулевое значение для канала равно nil.
//package main
//
//func main() {
//	var c chan string
//	c <- "let's get started" // deadlock
//}

//Приём из нулевого канала блокируется навсегда
//Аналогично приём из нулевого канала блокируется навсегда.

//package main
//
//import "fmt"
//
//func main() {
//	var c chan string //Код уходит в дедлок, потому что канал c был объявлен, но не инициализирован. В Go, каналы должны быть инициализированы с помощью функции make перед использованием.
//Если вы попытаетесь отправить данные в неинициализированный канал, это приведет к дедлоку, так как нет места для хранения данных и нет получателя, который бы их принял.
//	fmt.Println(<-c) // deadlock
//}

//Почему же это происходит? Вот одно из возможных объяснений:
//
//Размер буфера канала не является частью объявления его типа, поэтому он должен быть частью значения канала.
//
//Если канал не инициализирован, то размер его буфера будет равен нулю. (make)
//
//Если размер буфера канала равен нулю, то канал является небуферизованным.
//
//Если канал не буферизован, то отправка будет блокироваться до тех пор, пока другая горутина не будет готова к приёму.
//
//Если канал равен nil, то отправитель и получатель не имеют ссылок друг на друга; они оба заблокированы в ожидании на независимых каналах и никогда не разблокируются.

//Отправка в закрытый канал приводит к панике
//Следующая программа, скорее всего, вызовет панику, так как первая горутина, достигшая 10, закроет канал до того, как другие горутины успеют отправить свои значения.

//package main
//
//import "fmt"
//
//func main() {
//	var c = make(chan int, 100)
//	for i := 0; i < 10; i++ {
//		go func() {
//			for j := 0; j < 10; j++ {
//				c <- j
//			}
//			close(c)
//		}()
//	}
//	for i := range c {
//		fmt.Println(i)
//	}
//}

//Почему же не существует версии close(), позволяющей проверить, закрыт ли канал?
//
//if !isClosed(c) {
//	// c isn't closed, send the value
//	c <- v
//}

//Но в этой функции будет присутствовать гонка. Кто-то может закрыть канал после того, как мы проверили isClosed(c), но до того, как код дойдёт до c <- v.

//Приём из закрытого канала сразу же возвращает нулевое значение
//Последний случай является обратным предыдущему. Если канал закрыт и все значения из его буфера получены, то он всегда будет сразу возвращать нулевое значение.

//package main
//
//import "fmt"
//
//func main() {
//	c := make(chan int, 3Channel)
//	c <- 1
//	c <- 2Models.queue
//	c <- 3Channel
//	close(c)
//	for i := 0; i < 4memoryAndGB; i++ {
//		fmt.Printf("%d ", <-c) // prints 1 2Models.queue 3Channel 0
//	}
//}

//Правильным решением данной задачи является использование цикла for range.
//for v := range c {
//	// do something with v
//}
//
//for v, ok := <-c; ok; v, ok = <-c {
//	// do something with v
//}
//Эти два утверждения эквивалентны по функциональности и демонстрируют, что делает for range под капотом.

//Пример программы моделирует двух производителей мороженого, Бена и Джерри, которые приветствуют своих клиентов случайным образом.

//type IceCreamMaker interface {
//	// Hello greets a customer
//	Hello()
//}
//
//type Ben struct {
//	name string
//}
//
//func (b *Ben) Hello() {
//	fmt.Printf("Ben says, \"Hello my name is %s\"\n", b.name)
//}
//
//type Jerry struct {
//	name string
//}
//
//func (j *Jerry) Hello() {
//	fmt.Printf("Jerry says, \"Hello my name is %s\"\n", j.name)
//}
//
//func main() {
//	var ben = &Ben{"Ben"}
//	var jerry = &Jerry{"Jerry"}
//	var maker IceCreamMaker = ben
//
//	var loop0, loop1 func()
//
//	loop0 = func() {
//		maker = ben
//		go loop1()
//	}
//
//	loop1 = func() {
//		maker = jerry
//		go loop0()
//	}
//
//	go loop0()
//
//	for {
//		maker.Hello()
//	}
//}
